# -*- coding: utf-8 -*-
"""Parcial2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EMJbnFZugBO-P5hdLLkpaksmkXIBvKtx

##IMPLEMENTACIÓN TOPSIS
"""

def normaLP(matrizV, lp: str or int):
  '''
  Método auxiliar. Halla la norma de cada columna en una matriz.
  '''
  normas = []
  if lp == "infinity":
    matrizT = list(map(list, zip(*matrizV)))
    for i in range(len(matrizT)):
      normas.append(max(matrizT[i]))
  else:
    for j in range(len(matrizV[0])):
      suma = 0
      for i in range(len(matrizV)):
        suma = suma + abs(matrizV[i][j]**lp)
      normaJ = (suma)**(1./lp)
      normas.append(normaJ)
  return(normas)

def normalizarPond(matrizV, lp: str or int, pesos):
  '''
  Método auxiliar. Normaliza y pondera la matriz de decisión.
  '''
  normas = normaLP(matrizV, lp)
  for i in range(len(matrizV)):
    for j in range(len(matrizV[i])):
      matrizV[i][j] = matrizV[i][j]/normas[j]*pesos[j]
  return matrizV

def TOPSIS(matrizV, lp: str or int, pesos, tipo): 

  '''
  Implementación del método TOPSIS.
  Imprime el ranking de las alternativas, con sus respectivas proximidades a la solución ideal.

  Parámetros: 
  matrizV: Matriz de decisión, una lista de listas.
  lp: Norma que el usuario desee utilizar. Ej: 1, 2, "infinity".
  pesos: Lista de pesos en el mismo orden en el que van sus criterios correspondientes.
  tipo: Una lista de strs en donde se determina si el criterio es deseable o indeseable.
        Ej: ["deseable", "indeseable", "indeseable"]
  '''

  matrizPond = normalizarPond(matrizV, lp, pesos)
  ideales = []
  antiIdeales = []
  proximidad = []
  matrizT = list(map(list, zip(*matrizPond))) #Matriz traspuesta

  for i in range(len(matrizT)):
    if tipo[i] == "deseable":
      ideales.append(max(matrizT[i]))
      antiIdeales.append(min(matrizT[i]))
    else:
      ideales.append(min(matrizT[i]))
      antiIdeales.append(max(matrizT[i]))

  distAntiIdeal = []
  distIdeal = []

  if lp == "infinity":
    for i in range(len(matrizPond)):
      resta1 = []
      resta2 = []
      for j in range(len(matrizPond[i])):
        resta1.append(abs((ideales[j] - matrizPond[i][j])))
        resta2.append(abs((antiIdeales[j] - matrizPond[i][j])))
      distIdeal.append(max(resta1))
      distAntiIdeal.append(max(resta2))
      proximidad.append(distAntiIdeal[i]/(distIdeal[i]+distAntiIdeal[i]))
  else:
    for i in range(len(matrizPond)):
      suma1 = 0
      suma2 = 0
      for j in range(len(matrizPond[i])):
        suma1 = suma1 + abs((ideales[j] - matrizPond[i][j])**lp)
        suma2 = suma2 + abs((antiIdeales[j] - matrizPond[i][j])**lp)
      distIdeal.append((suma1)**(1./lp))
      distAntiIdeal.append((suma2)**(1./lp))
      proximidad.append(distAntiIdeal[i]/(distIdeal[i]+distAntiIdeal[i]))
  
  for i in range(len(proximidad)):
    proximidad[i] = (proximidad[i], "alternativa " + str(i+1))
  proximidad.sort(reverse=True)

  print("El ranking de las soluciones es el siguiente:")

  for i in range(len(proximidad)):
    print("La alternativa en el puesto número " + str(i+1) + " es la " + str(proximidad[i][1]) + " con una proximidad a la solución ideal de " + str(proximidad[i][0]))

#TOPSIS([[185,6.5,12.85],[290,7.5,13.695],[310,7.6,12.87],[245, 6.5,11.385],[325,7.55, 11.235],[235,6.85, 12.525]], 2,[0.3,0.4,0.3], ["indeseable", "indeseable", "deseable"])
TOPSIS([[1,5],[4,2],[3,3]], 1, [0.5,0.5], ["deseable", "deseable"])
